
-- Drop existing tables and policies if they exist to ensure a clean slate.
DROP POLICY IF EXISTS "Enable all access for authenticated users" ON "public"."app_settings";
DROP POLICY IF EXISTS "Enable read access for all users" ON "public"."app_settings";
DROP POLICY IF EXISTS "Enable all access for authenticated users" ON "public"."students";
DROP POLICY IF EXISTS "Enable read access for all users" ON "public"."students";
DROP POLICY IF EXISTS "Enable all access for authenticated users" ON "public"."awards";
DROP POLICY IF EXISTS "Enable read access for all users" ON "public"."awards";
DROP POLICY IF EXISTS "Enable all access for authenticated users" ON "public"."award_nominations";
DROP POLICY IF EXISTS "Enable read access for all users" ON "public"."award_nominations";

-- Drop the tables, cascading to dependent objects.
DROP TABLE IF EXISTS "public"."students" CASCADE;
DROP TABLE IF EXISTS "public"."app_settings" CASCADE;
DROP TABLE IF EXISTS "public"."awards" CASCADE;
DROP TABLE IF EXISTS "public"."award_nominations" CASCADE;

-- Recreate the tables with the correct schema.

-- Table: app_settings
CREATE TABLE IF NOT EXISTS "public"."app_settings" (
    "id" bigint NOT NULL,
    "created_at" timestamp with time zone NOT NULL DEFAULT now(),
    "logos" jsonb,
    "voting_settings" jsonb,
    "fyb_week_settings" jsonb,
    "updated_at" timestamp with time zone
);
ALTER TABLE "public"."app_settings" OWNER TO "postgres";
ALTER TABLE "public"."app_settings" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."app_settings_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);
ALTER TABLE ONLY "public"."app_settings" ADD CONSTRAINT "app_settings_pkey" PRIMARY KEY ("id");

-- Table: students
CREATE TABLE IF NOT EXISTS "public"."students" (
    "id" text NOT NULL,
    "name" text NOT NULL,
    "nickname" text,
    "best_level" text,
    "worst_level" text,
    "favourite_lecturer" text,
    "relationship_status" text,
    "alternative_career" text,
    "best_experience" text,
    "worst_experience" text,
    "will_miss" text,
    "image_src" text,
    "created_at" timestamp with time zone DEFAULT now(),
    "updated_at" timestamp with time zone DEFAULT now()
);
ALTER TABLE "public"."students" OWNER TO "postgres";
ALTER TABLE ONLY "public"."students" ADD CONSTRAINT "students_pkey" PRIMARY KEY ("id");

-- Table: awards
CREATE TABLE IF NOT EXISTS "public"."awards" (
    "id" uuid NOT NULL DEFAULT gen_random_uuid(),
    "name" text NOT NULL,
    "description" text,
    "created_at" timestamp with time zone DEFAULT now()
);
ALTER TABLE public.awards OWNER TO postgres;
ALTER TABLE ONLY public.awards ADD CONSTRAINT awards_pkey PRIMARY KEY (id);

-- Table: award_nominations
CREATE TABLE IF NOT EXISTS public.award_nominations (
    "id" uuid NOT NULL DEFAULT gen_random_uuid(),
    "award_id" uuid NOT NULL,
    "student_id" text NOT NULL,
    "votes" integer DEFAULT 0 NOT NULL,
    "created_at" timestamp with time zone DEFAULT now()
);
ALTER TABLE public.award_nominations OWNER TO postgres;
ALTER TABLE ONLY public.award_nominations ADD CONSTRAINT award_nominations_pkey PRIMARY KEY (id);
ALTER TABLE ONLY public.award_nominations ADD CONSTRAINT award_nominations_award_id_fkey FOREIGN KEY (award_id) REFERENCES public.awards(id) ON DELETE CASCADE;
ALTER TABLE ONLY public.award_nominations ADD CONSTRAINT award_nominations_student_id_fkey FOREIGN KEY (student_id) REFERENCES public.students(id) ON DELETE CASCADE;
ALTER TABLE ONLY public.award_nominations ADD CONSTRAINT unique_award_student_nomination UNIQUE (award_id, student_id);


-- Enable Row Level Security for all tables
ALTER TABLE "public"."app_settings" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."students" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."awards" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."award_nominations" ENABLE ROW LEVEL SECURITY;

-- Create policies for app_settings
CREATE POLICY "Enable read access for all users" ON "public"."app_settings" FOR SELECT USING (true);
CREATE POLICY "Enable all access for authenticated users" ON "public"."app_settings" FOR ALL USING (auth.role() = 'authenticated') WITH CHECK (auth.role() = 'authenticated');

-- Create policies for students
CREATE POLICY "Enable read access for all users" ON "public"."students" FOR SELECT USING (true);
CREATE POLICY "Enable all access for authenticated users" ON "public"."students" FOR ALL USING (auth.role() = 'authenticated') WITH CHECK (auth.role() = 'authenticated');

-- Create policies for awards
CREATE POLICY "Enable read access for all users" ON "public"."awards" FOR SELECT USING (true);
CREATE POLICY "Enable all access for authenticated users" ON "public"."awards" FOR ALL USING (auth.role() = 'authenticated') WITH CHECK (auth.role() = 'authenticated');

-- Create policies for award_nominations
CREATE POLICY "Enable read access for all users" ON "public"."award_nominations" FOR SELECT USING (true);
CREATE POLICY "Enable all access for authenticated users" ON "public"."award_nominations" FOR ALL USING (auth.role() = 'authenticated') WITH CHECK (auth.role() = 'authenticated');

-- Create an RPC function to increment votes safely
CREATE OR REPLACE FUNCTION increment_vote(nomination_id_in uuid)
RETURNS void
LANGUAGE plpgsql
AS $$
BEGIN
  UPDATE public.award_nominations
  SET votes = votes + 1
  WHERE id = nomination_id_in;
END;
$$;
